[TOC]



## ES6

### 声明变量

#### 变量提升

将函数的和变量的声明提升到函数的最顶部，变量可以先使用后声明。只有声明的变量才会提升，初始化的不会。

声明：`var a;`

初始化：`var a=5;`

```js
console.log(a);  //undefined (因为a仅是声明提升了，但是在这里还未赋值)
console.log(b);  //报错：b is not defined  （b还没有声明，找不到b变量）

var a = 100;
let b = 10;

console.log(a);  // 100
console.log(b);  // 10
```

#### 函数提升

创建函数有两种形式：1. 函数声明：会率先读取；2. 函数字面量：执行到该代码才读取

**只有函数声明的形式才会有变量提升**，即可以先用后定义

```javascript
console.log(a);   // f a () { console.log(a) }
console.log(b);   //undefined

function a () {
    console.log(a)
}
var b = function () {
    console.log(b)
}
```

等价于

```javascript
var a = 'function';
var b;
console.log(a);
console.log(b);
```

#### 变量提升与函数提升的优先级

函数提升比变量提升优先级高，并且不会被变量声明覆盖，但是会被变量赋值之后覆盖

```javascript
console.log(a);     // f a () { console.log(10) }  （函数提升）
console.log(a());   //undefined   （只是函数声明提升，对函数的执行需要等到读取到那部分代码之后）

var a = 5;
function a() {
    console.log(10)
}

console.log(a);     //5      （被变量赋值给覆盖了）
console.log(a());   //报错：a is not defined   （被变量赋值给覆盖了，a不是一个函数了）
```

#### 关键字

1. `var`：
   - 声明的变量没有定义作用域，是全局的会挂在window上
   - <u>有变量提升</u>
   - 可以重复声明同名变量
2. let：
   - 声明时候定义作用域，只在当前作用域中有效
   - 无变量提升
   - 不可重复声明同名变量
3. `let`：声明时候定义作用域，<u>只在当前作用域中有效</u>，无变量提升，不可重复声明一个变量
4. `const`：
   - 声明时候定义作用域
   - 声明变量之后不可以改变它的值(用于声明常量)
   - 无变量提升
   - 不可重复声明同名变量
   - <u>声明变量的时候一定得赋值</u>。

### 集合Set类 

#### 创建

let set = new Set (['张','李','王'])

#### 属性

size

#### 方法

1. add()
2. delate()
3. has()
4. clear()

### 集合Map类

#### 创建

```javascript
let map = new Map ([
    				['name','张'],
    				['age',18],
    				['sex','男']
    				[obj1,'今天天气很好']
				   ])
```

#### 方法

1. set()
2. get()
3. delate()
4. has()
5. key()
6. value()
7. entries()
8. forEach()

### 箭头函数

#### 语法

```javascript
() => console.log('Hello')

等价于

function() {

console.log('Hello')

}
```

#### 优点

使函数简洁

#### 区别

与普通函数的区别：

1. 不绑定`this`的作用域，`this`的值指向其父级作用域
2. 没有argument对象



**argument对象**：是所有（非箭头）函数中都可用的**局部变量**。此对象包含传递给函数的每一个参数，可以使用argument对象在函数中引用函数的参数。比如引用第一个参数可以使用`argument[0]`。

argument对象不是一个`Array`，没有`pop`等方法，但是可以转化为一个`Array`

## 排序方法

### 快速排序

理解：快速排序是将一队有待排序的序列不断分割，选取一个基准，将序列分为两个子序列，基准左边的元素比基准小，基准右边的元素比基准的大。对子序列再递归的分割，直到序列只有一个元素的时候不再分割。

#### 复杂度：

1. 时间复杂度：O(nlogn)，最坏情况下为O(n²)
2. 空间复杂度：O(logn)

#### 步骤：

1. 选取基准数
2. 对原始数组以基准数为中间值进行左右分割，左边比基准数小右边比基准数大
3. 递归使用方法1和2使得最后数组被分为仅有一个元素的数组

#### 选取基准：

 1. 取第一个或最后一个

 2. 取中间的：`Math.floor((left+right)/2)`

 3. 随机选取：`rand()%(hight - low) +low`

 4. 三数取中：数组中最小下标、中间下标、最大下标的数字进行比较，选取中间的值作为基准数放到最左边。（解决基本有序的序列比较快）

    ```js
    if (array[left] > array[right]) {
    
    	swap(array[left], array[right])
    
    }
    
     if (array[mid] > array[left]) {
    
    	swap(array[mid], array[left])
    
    }
    
    if (array[mid] > array[right]) {
    
    	swap(array[mid], array[right])
    
    }
    ```

    此时，`arr[mid] <= arr[low] <= arr[high]`最左边放着三个数中间值

#### 优化方法：

1. 快排+插排：对于分割到一定长度的小数组使用插入法排序
2. 第一次分割完将与基准数相同的元素放在一起，不再对与基准数相等的元素分割

### 归并排序

理解：归并是一种分治算法，将原始数组分成小的数组，直到每个数组都只有一个元素，再将小数组不断组成最后成为一个排序好的大数组。

#### 复杂度：

1. 时间复杂度：O(nlogn)
2. 空间复杂度：O(n)

#### 步骤：

1. 取中间的位置为中点分割数组
2. 递归1直到子数组只有1个元素
3. 递归将子数组从小到大的合并

#### 优化方法：

1. 归并+快插：对于分割到一定长度的小数组使用插入法排序
2. 调用`merge()`对数组进行递归排序，调用之前可以先判断`a[mid] < a[mid+1]`是否成立，若成立不需再归并，因为i已经是有序的。

### 桶排序

理解：桶排序将一队数据分到有限数量的桶内，再对每个桶分别排序(可以使用其他的排序方法进行排序或者继续递归使用桶排)。每个桶都对应一定的数字范围。

#### 复杂度：

1. 时间复杂度：平均：O(n+k)
2. 空间复杂度： O(n+k)

#### 步骤：

1. 设置桶的数量
2. 把数据放到相应桶中，放入时候按大小位置放置相应位置
3. 拼接桶



























